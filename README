实验二syscall:
exercise1:
陷入帧：陷入帧（trap frame）是系统在处理异常、系统调用或中断时保存的寄存器状态的结构体。它记录了在发生异常或中断时，CPU的寄存器状态、程序计数器（PC）、栈指针等信息，以便在处理中断或异常后能够恢复到中断或异常发生前的状态。
内核空间和用户空间的寄存器不互通的，陷入帧保存的是用户空间的寄存器数据保存在内核空间中，内核是拥有对用户空间的寄存器的单向访问权的。
argint(0, &mask) :调用 argint 函数从用户空间获取系统调用参数。argint 函数的第一个参数是参数的索引，0 表示第一个参数。这个函数会把用户空间传递的参数值存储到 mask 变量中。如果 argint 函数返回值小于 0，表示获取参数失败（例如，参数不合法），则执行 { return -1; }。
Q：当我在2.c文件中写入extern uint64 sys_trace(void);而该函数的实现在1.c中写出，2.c包含了1.h,1.h没有声明该函数，则在2.c中可以正常使用该函数吗？
编译器会假设 sys_trace 函数的声明存在于 2.c 文件中，进行编译。
链接器: 在链接阶段，链接器会将 2.c 中对 sys_trace 的调用与 1.c 中的实际实现进行匹配。只要 sys_trace 在 1.c 中有实际的定义，并且 1.c 被正确地编译并链接到最终的可执行文件中，链接器就会将函数调用的地址与定义进行关联。
在实际情况下，即使 1.h 中没有声明 sys_trace，只要 2.c 正确地声明了 sys_trace 函数，并且 1.c 中包含了函数的定义，编译和链接过程应该能够正常进行，2.c 文件中的代码将能够调用 sys_trace 函数。
https://github.com/jlu-xiurui/MIT6.S081-2021-FALL/blob/master/lab2-syscall/user/_trace
curl -o ../ https://github.com/jlu-xiurui/MIT6.S081-2021-FALL/blob/master/lab2-syscall/user/_sysinfotest

 exec 会替换进程的代码段、数据段、堆和栈，但是进程控制块（PCB）中的某些属性，例如 trace_mask，不会被重置。

git commit -am 'my solution for syscall lab exercise 1'

exercise2:
实验聚焦于实现把sysinfo这个结构体从内核内存拷贝到用户内存中，并实现获取空域内存和已经创建的进程数量。
copyout()函数定义：
// Copy len bytes from src to virtual address dstva in a given page table.
// 把在内核地址src开始的len大小的数据拷贝到用户进程pagetable的虚地址dstva处
copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
使用的实例：
filestat函数中关于copyout函数的用法
if(copyout(p->pagetable, addr, (char *)&st, sizeof(st)) < 0)
      return -1;

Q：在1.c中定义了一个函数，并且其没有1.h头文件，那在2.c文件中声明该函数后就可以使用该函数了吗？原理是什么？
A：是的，在 1.c 中定义的函数，如果在 2.c 文件中通过 extern 声明该函数，那么你就可以在 2.c 文件中使用该函数。当你在 2.c 文件中使用 extern 声明 1.c 中定义的函数时，实际上是在告诉编译器：“这个函数的实现存在于其他文件中。”编译器因此会将函数调用的细节放在编译后的目标文件中，并在链接阶段将其与定义在 1.c 中的函数的实现关联起来。

ATTENTION:
1.
struct {
  struct spinlock lock;
  struct run *freelist;
} kmem;结构体是一个匿名结构体，在定义结构体时就创建结构体变量，且为全局变量，程序的整个生命周期内都是可用的，可以在程序的任何地方访问。
2.
在 C 语言中，如果一个常量宏（如 PGSIZE）已经在某个头文件中定义，那么在其他 .c 文件中只需要包含该头文件就可以使用该宏，而不需要再额外声明或定义。


Q：
struct proc *p;
uint64 ret = 0;
for (p = proc; p < &proc[NPROC]; p++)p++是地址加了一个字节还是4字节还是8字节？
A:
p++会根据指针p指向的数据类型来决定加多少个字节，平时一个指向struct proc类型的指针，因此p++会将p的地址增加一个struct proc结构体的大小。

Q：
(char*)&info作用
A:
(char*)&info 是将 &info（struct sysinfo * 类型）转换为 char* 类型的指针。
这种转换允许你以字节为单位访问 info 变量在内存中的数据。这种转换通常在以下情况下使用：
内存操作: 你可能需要逐字节处理结构体中的数据，例如在序列化或传输数据时。
调试: 有时你可能想以字节级别查看结构体的内容，转换为 char* 可以让你逐字节地遍历结构体。

