Q1:哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？
A1:根据RISCV手册，a0-a7寄存器保存了函数的参数，在`printf`中，参数13被存储在a2寄存器中。
Q2:main的汇编代码中对函数f的调用在哪里？对g的调用在哪里（提示：编译器可能会将函数内联）
A2:编译器在生成汇编代码时进行了优化（内联优化），将对f的调用直接计算结果，并将结果加载到寄存器a1（li	a1,12），因而在汇编代码中并未生成相关的调用指令。
Q3:printf函数位于哪个地址？
A3:  
30:	00000097          	auipc	ra,0x0将当前pc高20位与0x0合并并放入寄存器ra中，当前PC为0x30.
34:	600080e7          	jalr	1536(ra) # 630 <printf>该指令会将ra寄存器的值加上1536，然后跳转到该地址，即为printf函数的地址。
0x30+1536=0x630。
Q4：在main中printf的jalr之后的寄存器ra中有什么值？
A4:
`jalr offset(rd)`的功能为：`t =pc+4; pc=(x[rs1]+sext(offset))&~1; x[rd]=t`。因此在jalr跳转至printf后，ra会保存调用后返回地址，下一条指令地址为0x34+4=0x38
在返回时，程序会利用ra中的地址0x38地址恢复主函数并继续执行。
Q5： 运行以下代码:
	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
​输出是什么？上述输出是基于RISC-V为小端法的事实的。如果RISC-V为大端法，i应该被设置为什么，57616需要被改变吗?
输出为Hell0 World,57616的16进制为0xell0,0x00646c72在内存中存储的内容按字节顺序为 72 6c 64 00，分别对应字符 'r'、'l'、'd' 和空字符 '\0'。
如果为大端存储，i需要更改为0x726c6400,而57616则不需要更改，因为大端法与小端法的区别在于数据的存储顺序，而非数据的实际值，硬件会处理具体的存储和读取方式。
6. 在下面的代码中，会打印 `'y='`什么？为什么会发生这种情况？
	printf("x=%dy=%d", 3);
不太确定，可能取决于`a2` 寄存器当前的值，因为在调用 `printf` 时，并未给 `a2` 寄存器赋值。但是在我尝试了几次，输出的都是0，难道是编译器进行了优化吗？